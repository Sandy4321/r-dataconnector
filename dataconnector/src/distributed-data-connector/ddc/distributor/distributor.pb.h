/*
(c) Copyright 2015 Hewlett Packard Enterprise Development LP

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/


// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: distributor.proto

#ifndef PROTOBUF_distributor_2eproto__INCLUDED
#define PROTOBUF_distributor_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace ddc {
namespace distributor {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_distributor_2eproto();
void protobuf_AssignDesc_distributor_2eproto();
void protobuf_ShutdownFile_distributor_2eproto();

class Registration;
class FetchSplitRequest;
class FetchSplitResponse;
class HeartBeatRequest;
class HeartBeatResponse;
class ShutdownRequest;
class ProgressUpdate;
class AnyRequest;

enum AnyRequest_Type {
  AnyRequest_Type_REGISTRATION = 1,
  AnyRequest_Type_FETCH_SPLIT_REQUEST = 2,
  AnyRequest_Type_FETCH_SPLIT_RESPONSE = 3,
  AnyRequest_Type_HEARTBEAT_REQUEST = 4,
  AnyRequest_Type_HEARTBEAT_RESPONSE = 5,
  AnyRequest_Type_SHUTDOWN_REQUEST = 6,
  AnyRequest_Type_PROGRESS_UPDATE = 7
};
bool AnyRequest_Type_IsValid(int value);
const AnyRequest_Type AnyRequest_Type_Type_MIN = AnyRequest_Type_REGISTRATION;
const AnyRequest_Type AnyRequest_Type_Type_MAX = AnyRequest_Type_PROGRESS_UPDATE;
const int AnyRequest_Type_Type_ARRAYSIZE = AnyRequest_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* AnyRequest_Type_descriptor();
inline const ::std::string& AnyRequest_Type_Name(AnyRequest_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    AnyRequest_Type_descriptor(), value);
}
inline bool AnyRequest_Type_Parse(
    const ::std::string& name, AnyRequest_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AnyRequest_Type>(
    AnyRequest_Type_descriptor(), name, value);
}
// ===================================================================

class Registration : public ::google::protobuf::Message {
 public:
  Registration();
  virtual ~Registration();

  Registration(const Registration& from);

  inline Registration& operator=(const Registration& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Registration& default_instance();

  void Swap(Registration* other);

  // implements Message ----------------------------------------------

  Registration* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Registration& from);
  void MergeFrom(const Registration& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // repeated string ipAddress = 2;
  inline int ipaddress_size() const;
  inline void clear_ipaddress();
  static const int kIpAddressFieldNumber = 2;
  inline const ::std::string& ipaddress(int index) const;
  inline ::std::string* mutable_ipaddress(int index);
  inline void set_ipaddress(int index, const ::std::string& value);
  inline void set_ipaddress(int index, const char* value);
  inline void set_ipaddress(int index, const char* value, size_t size);
  inline ::std::string* add_ipaddress();
  inline void add_ipaddress(const ::std::string& value);
  inline void add_ipaddress(const char* value);
  inline void add_ipaddress(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& ipaddress() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_ipaddress();

  // @@protoc_insertion_point(class_scope:ddc.distributor.Registration)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* id_;
  ::google::protobuf::RepeatedPtrField< ::std::string> ipaddress_;
  friend void  protobuf_AddDesc_distributor_2eproto();
  friend void protobuf_AssignDesc_distributor_2eproto();
  friend void protobuf_ShutdownFile_distributor_2eproto();

  void InitAsDefaultInstance();
  static Registration* default_instance_;
};
// -------------------------------------------------------------------

class FetchSplitRequest : public ::google::protobuf::Message {
 public:
  FetchSplitRequest();
  virtual ~FetchSplitRequest();

  FetchSplitRequest(const FetchSplitRequest& from);

  inline FetchSplitRequest& operator=(const FetchSplitRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FetchSplitRequest& default_instance();

  void Swap(FetchSplitRequest* other);

  // implements Message ----------------------------------------------

  FetchSplitRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FetchSplitRequest& from);
  void MergeFrom(const FetchSplitRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string tag = 1;
  inline bool has_tag() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 1;
  inline const ::std::string& tag() const;
  inline void set_tag(const ::std::string& value);
  inline void set_tag(const char* value);
  inline void set_tag(const char* value, size_t size);
  inline ::std::string* mutable_tag();
  inline ::std::string* release_tag();
  inline void set_allocated_tag(::std::string* tag);

  // required string filename = 2;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFilenameFieldNumber = 2;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  inline void set_allocated_filename(::std::string* filename);

  // required uint64 start = 3;
  inline bool has_start() const;
  inline void clear_start();
  static const int kStartFieldNumber = 3;
  inline ::google::protobuf::uint64 start() const;
  inline void set_start(::google::protobuf::uint64 value);

  // required uint64 end = 4;
  inline bool has_end() const;
  inline void clear_end();
  static const int kEndFieldNumber = 4;
  inline ::google::protobuf::uint64 end() const;
  inline void set_end(::google::protobuf::uint64 value);

  // required string schema = 5;
  inline bool has_schema() const;
  inline void clear_schema();
  static const int kSchemaFieldNumber = 5;
  inline const ::std::string& schema() const;
  inline void set_schema(const ::std::string& value);
  inline void set_schema(const char* value);
  inline void set_schema(const char* value, size_t size);
  inline ::std::string* mutable_schema();
  inline ::std::string* release_schema();
  inline void set_allocated_schema(::std::string* schema);

  // required string objectType = 6;
  inline bool has_objecttype() const;
  inline void clear_objecttype();
  static const int kObjectTypeFieldNumber = 6;
  inline const ::std::string& objecttype() const;
  inline void set_objecttype(const ::std::string& value);
  inline void set_objecttype(const char* value);
  inline void set_objecttype(const char* value, size_t size);
  inline ::std::string* mutable_objecttype();
  inline ::std::string* release_objecttype();
  inline void set_allocated_objecttype(::std::string* objecttype);

  // @@protoc_insertion_point(class_scope:ddc.distributor.FetchSplitRequest)
 private:
  inline void set_has_tag();
  inline void clear_has_tag();
  inline void set_has_filename();
  inline void clear_has_filename();
  inline void set_has_start();
  inline void clear_has_start();
  inline void set_has_end();
  inline void clear_has_end();
  inline void set_has_schema();
  inline void clear_has_schema();
  inline void set_has_objecttype();
  inline void clear_has_objecttype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* tag_;
  ::std::string* filename_;
  ::google::protobuf::uint64 start_;
  ::google::protobuf::uint64 end_;
  ::std::string* schema_;
  ::std::string* objecttype_;
  friend void  protobuf_AddDesc_distributor_2eproto();
  friend void protobuf_AssignDesc_distributor_2eproto();
  friend void protobuf_ShutdownFile_distributor_2eproto();

  void InitAsDefaultInstance();
  static FetchSplitRequest* default_instance_;
};
// -------------------------------------------------------------------

class FetchSplitResponse : public ::google::protobuf::Message {
 public:
  FetchSplitResponse();
  virtual ~FetchSplitResponse();

  FetchSplitResponse(const FetchSplitResponse& from);

  inline FetchSplitResponse& operator=(const FetchSplitResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FetchSplitResponse& default_instance();

  void Swap(FetchSplitResponse* other);

  // implements Message ----------------------------------------------

  FetchSplitResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FetchSplitResponse& from);
  void MergeFrom(const FetchSplitResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string tag = 1;
  inline bool has_tag() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 1;
  inline const ::std::string& tag() const;
  inline void set_tag(const ::std::string& value);
  inline void set_tag(const char* value);
  inline void set_tag(const char* value, size_t size);
  inline ::std::string* mutable_tag();
  inline ::std::string* release_tag();
  inline void set_allocated_tag(::std::string* tag);

  // required int32 status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ddc.distributor.FetchSplitResponse)
 private:
  inline void set_has_tag();
  inline void clear_has_tag();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* tag_;
  ::google::protobuf::int32 status_;
  friend void  protobuf_AddDesc_distributor_2eproto();
  friend void protobuf_AssignDesc_distributor_2eproto();
  friend void protobuf_ShutdownFile_distributor_2eproto();

  void InitAsDefaultInstance();
  static FetchSplitResponse* default_instance_;
};
// -------------------------------------------------------------------

class HeartBeatRequest : public ::google::protobuf::Message {
 public:
  HeartBeatRequest();
  virtual ~HeartBeatRequest();

  HeartBeatRequest(const HeartBeatRequest& from);

  inline HeartBeatRequest& operator=(const HeartBeatRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HeartBeatRequest& default_instance();

  void Swap(HeartBeatRequest* other);

  // implements Message ----------------------------------------------

  HeartBeatRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HeartBeatRequest& from);
  void MergeFrom(const HeartBeatRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ddc.distributor.HeartBeatRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_distributor_2eproto();
  friend void protobuf_AssignDesc_distributor_2eproto();
  friend void protobuf_ShutdownFile_distributor_2eproto();

  void InitAsDefaultInstance();
  static HeartBeatRequest* default_instance_;
};
// -------------------------------------------------------------------

class HeartBeatResponse : public ::google::protobuf::Message {
 public:
  HeartBeatResponse();
  virtual ~HeartBeatResponse();

  HeartBeatResponse(const HeartBeatResponse& from);

  inline HeartBeatResponse& operator=(const HeartBeatResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HeartBeatResponse& default_instance();

  void Swap(HeartBeatResponse* other);

  // implements Message ----------------------------------------------

  HeartBeatResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HeartBeatResponse& from);
  void MergeFrom(const HeartBeatResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ddc.distributor.HeartBeatResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_distributor_2eproto();
  friend void protobuf_AssignDesc_distributor_2eproto();
  friend void protobuf_ShutdownFile_distributor_2eproto();

  void InitAsDefaultInstance();
  static HeartBeatResponse* default_instance_;
};
// -------------------------------------------------------------------

class ShutdownRequest : public ::google::protobuf::Message {
 public:
  ShutdownRequest();
  virtual ~ShutdownRequest();

  ShutdownRequest(const ShutdownRequest& from);

  inline ShutdownRequest& operator=(const ShutdownRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ShutdownRequest& default_instance();

  void Swap(ShutdownRequest* other);

  // implements Message ----------------------------------------------

  ShutdownRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ShutdownRequest& from);
  void MergeFrom(const ShutdownRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ddc.distributor.ShutdownRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_distributor_2eproto();
  friend void protobuf_AssignDesc_distributor_2eproto();
  friend void protobuf_ShutdownFile_distributor_2eproto();

  void InitAsDefaultInstance();
  static ShutdownRequest* default_instance_;
};
// -------------------------------------------------------------------

class ProgressUpdate : public ::google::protobuf::Message {
 public:
  ProgressUpdate();
  virtual ~ProgressUpdate();

  ProgressUpdate(const ProgressUpdate& from);

  inline ProgressUpdate& operator=(const ProgressUpdate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProgressUpdate& default_instance();

  void Swap(ProgressUpdate* other);

  // implements Message ----------------------------------------------

  ProgressUpdate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProgressUpdate& from);
  void MergeFrom(const ProgressUpdate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string tag = 1;
  inline bool has_tag() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 1;
  inline const ::std::string& tag() const;
  inline void set_tag(const ::std::string& value);
  inline void set_tag(const char* value);
  inline void set_tag(const char* value, size_t size);
  inline ::std::string* mutable_tag();
  inline ::std::string* release_tag();
  inline void set_allocated_tag(::std::string* tag);

  // required uint64 bytesCompleted = 2;
  inline bool has_bytescompleted() const;
  inline void clear_bytescompleted();
  static const int kBytesCompletedFieldNumber = 2;
  inline ::google::protobuf::uint64 bytescompleted() const;
  inline void set_bytescompleted(::google::protobuf::uint64 value);

  // required uint64 bytesTotal = 3;
  inline bool has_bytestotal() const;
  inline void clear_bytestotal();
  static const int kBytesTotalFieldNumber = 3;
  inline ::google::protobuf::uint64 bytestotal() const;
  inline void set_bytestotal(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:ddc.distributor.ProgressUpdate)
 private:
  inline void set_has_tag();
  inline void clear_has_tag();
  inline void set_has_bytescompleted();
  inline void clear_has_bytescompleted();
  inline void set_has_bytestotal();
  inline void clear_has_bytestotal();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* tag_;
  ::google::protobuf::uint64 bytescompleted_;
  ::google::protobuf::uint64 bytestotal_;
  friend void  protobuf_AddDesc_distributor_2eproto();
  friend void protobuf_AssignDesc_distributor_2eproto();
  friend void protobuf_ShutdownFile_distributor_2eproto();

  void InitAsDefaultInstance();
  static ProgressUpdate* default_instance_;
};
// -------------------------------------------------------------------

class AnyRequest : public ::google::protobuf::Message {
 public:
  AnyRequest();
  virtual ~AnyRequest();

  AnyRequest(const AnyRequest& from);

  inline AnyRequest& operator=(const AnyRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AnyRequest& default_instance();

  void Swap(AnyRequest* other);

  // implements Message ----------------------------------------------

  AnyRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AnyRequest& from);
  void MergeFrom(const AnyRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef AnyRequest_Type Type;
  static const Type REGISTRATION = AnyRequest_Type_REGISTRATION;
  static const Type FETCH_SPLIT_REQUEST = AnyRequest_Type_FETCH_SPLIT_REQUEST;
  static const Type FETCH_SPLIT_RESPONSE = AnyRequest_Type_FETCH_SPLIT_RESPONSE;
  static const Type HEARTBEAT_REQUEST = AnyRequest_Type_HEARTBEAT_REQUEST;
  static const Type HEARTBEAT_RESPONSE = AnyRequest_Type_HEARTBEAT_RESPONSE;
  static const Type SHUTDOWN_REQUEST = AnyRequest_Type_SHUTDOWN_REQUEST;
  static const Type PROGRESS_UPDATE = AnyRequest_Type_PROGRESS_UPDATE;
  static inline bool Type_IsValid(int value) {
    return AnyRequest_Type_IsValid(value);
  }
  static const Type Type_MIN =
    AnyRequest_Type_Type_MIN;
  static const Type Type_MAX =
    AnyRequest_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    AnyRequest_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return AnyRequest_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return AnyRequest_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return AnyRequest_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .ddc.distributor.AnyRequest.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::ddc::distributor::AnyRequest_Type type() const;
  inline void set_type(::ddc::distributor::AnyRequest_Type value);

  // optional .ddc.distributor.Registration registration = 2;
  inline bool has_registration() const;
  inline void clear_registration();
  static const int kRegistrationFieldNumber = 2;
  inline const ::ddc::distributor::Registration& registration() const;
  inline ::ddc::distributor::Registration* mutable_registration();
  inline ::ddc::distributor::Registration* release_registration();
  inline void set_allocated_registration(::ddc::distributor::Registration* registration);

  // optional .ddc.distributor.FetchSplitRequest fetchSplitRequest = 3;
  inline bool has_fetchsplitrequest() const;
  inline void clear_fetchsplitrequest();
  static const int kFetchSplitRequestFieldNumber = 3;
  inline const ::ddc::distributor::FetchSplitRequest& fetchsplitrequest() const;
  inline ::ddc::distributor::FetchSplitRequest* mutable_fetchsplitrequest();
  inline ::ddc::distributor::FetchSplitRequest* release_fetchsplitrequest();
  inline void set_allocated_fetchsplitrequest(::ddc::distributor::FetchSplitRequest* fetchsplitrequest);

  // optional .ddc.distributor.FetchSplitResponse fetchSplitResponse = 4;
  inline bool has_fetchsplitresponse() const;
  inline void clear_fetchsplitresponse();
  static const int kFetchSplitResponseFieldNumber = 4;
  inline const ::ddc::distributor::FetchSplitResponse& fetchsplitresponse() const;
  inline ::ddc::distributor::FetchSplitResponse* mutable_fetchsplitresponse();
  inline ::ddc::distributor::FetchSplitResponse* release_fetchsplitresponse();
  inline void set_allocated_fetchsplitresponse(::ddc::distributor::FetchSplitResponse* fetchsplitresponse);

  // optional .ddc.distributor.HeartBeatRequest heartBeatRequest = 5;
  inline bool has_heartbeatrequest() const;
  inline void clear_heartbeatrequest();
  static const int kHeartBeatRequestFieldNumber = 5;
  inline const ::ddc::distributor::HeartBeatRequest& heartbeatrequest() const;
  inline ::ddc::distributor::HeartBeatRequest* mutable_heartbeatrequest();
  inline ::ddc::distributor::HeartBeatRequest* release_heartbeatrequest();
  inline void set_allocated_heartbeatrequest(::ddc::distributor::HeartBeatRequest* heartbeatrequest);

  // optional .ddc.distributor.HeartBeatResponse heartBeatResponse = 6;
  inline bool has_heartbeatresponse() const;
  inline void clear_heartbeatresponse();
  static const int kHeartBeatResponseFieldNumber = 6;
  inline const ::ddc::distributor::HeartBeatResponse& heartbeatresponse() const;
  inline ::ddc::distributor::HeartBeatResponse* mutable_heartbeatresponse();
  inline ::ddc::distributor::HeartBeatResponse* release_heartbeatresponse();
  inline void set_allocated_heartbeatresponse(::ddc::distributor::HeartBeatResponse* heartbeatresponse);

  // optional .ddc.distributor.ShutdownRequest shutdownRequest = 7;
  inline bool has_shutdownrequest() const;
  inline void clear_shutdownrequest();
  static const int kShutdownRequestFieldNumber = 7;
  inline const ::ddc::distributor::ShutdownRequest& shutdownrequest() const;
  inline ::ddc::distributor::ShutdownRequest* mutable_shutdownrequest();
  inline ::ddc::distributor::ShutdownRequest* release_shutdownrequest();
  inline void set_allocated_shutdownrequest(::ddc::distributor::ShutdownRequest* shutdownrequest);

  // optional .ddc.distributor.ProgressUpdate progressUpdate = 8;
  inline bool has_progressupdate() const;
  inline void clear_progressupdate();
  static const int kProgressUpdateFieldNumber = 8;
  inline const ::ddc::distributor::ProgressUpdate& progressupdate() const;
  inline ::ddc::distributor::ProgressUpdate* mutable_progressupdate();
  inline ::ddc::distributor::ProgressUpdate* release_progressupdate();
  inline void set_allocated_progressupdate(::ddc::distributor::ProgressUpdate* progressupdate);

  // @@protoc_insertion_point(class_scope:ddc.distributor.AnyRequest)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_registration();
  inline void clear_has_registration();
  inline void set_has_fetchsplitrequest();
  inline void clear_has_fetchsplitrequest();
  inline void set_has_fetchsplitresponse();
  inline void clear_has_fetchsplitresponse();
  inline void set_has_heartbeatrequest();
  inline void clear_has_heartbeatrequest();
  inline void set_has_heartbeatresponse();
  inline void clear_has_heartbeatresponse();
  inline void set_has_shutdownrequest();
  inline void clear_has_shutdownrequest();
  inline void set_has_progressupdate();
  inline void clear_has_progressupdate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::ddc::distributor::Registration* registration_;
  ::ddc::distributor::FetchSplitRequest* fetchsplitrequest_;
  ::ddc::distributor::FetchSplitResponse* fetchsplitresponse_;
  ::ddc::distributor::HeartBeatRequest* heartbeatrequest_;
  ::ddc::distributor::HeartBeatResponse* heartbeatresponse_;
  ::ddc::distributor::ShutdownRequest* shutdownrequest_;
  ::ddc::distributor::ProgressUpdate* progressupdate_;
  int type_;
  friend void  protobuf_AddDesc_distributor_2eproto();
  friend void protobuf_AssignDesc_distributor_2eproto();
  friend void protobuf_ShutdownFile_distributor_2eproto();

  void InitAsDefaultInstance();
  static AnyRequest* default_instance_;
};
// ===================================================================


// ===================================================================

// Registration

// required string id = 1;
inline bool Registration::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Registration::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Registration::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Registration::clear_id() {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& Registration::id() const {
  // @@protoc_insertion_point(field_get:ddc.distributor.Registration.id)
  return *id_;
}
inline void Registration::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set:ddc.distributor.Registration.id)
}
inline void Registration::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set_char:ddc.distributor.Registration.id)
}
inline void Registration::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ddc.distributor.Registration.id)
}
inline ::std::string* Registration::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ddc.distributor.Registration.id)
  return id_;
}
inline ::std::string* Registration::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Registration::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ddc.distributor.Registration.id)
}

// repeated string ipAddress = 2;
inline int Registration::ipaddress_size() const {
  return ipaddress_.size();
}
inline void Registration::clear_ipaddress() {
  ipaddress_.Clear();
}
inline const ::std::string& Registration::ipaddress(int index) const {
  // @@protoc_insertion_point(field_get:ddc.distributor.Registration.ipAddress)
  return ipaddress_.Get(index);
}
inline ::std::string* Registration::mutable_ipaddress(int index) {
  // @@protoc_insertion_point(field_mutable:ddc.distributor.Registration.ipAddress)
  return ipaddress_.Mutable(index);
}
inline void Registration::set_ipaddress(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:ddc.distributor.Registration.ipAddress)
  ipaddress_.Mutable(index)->assign(value);
}
inline void Registration::set_ipaddress(int index, const char* value) {
  ipaddress_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ddc.distributor.Registration.ipAddress)
}
inline void Registration::set_ipaddress(int index, const char* value, size_t size) {
  ipaddress_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ddc.distributor.Registration.ipAddress)
}
inline ::std::string* Registration::add_ipaddress() {
  return ipaddress_.Add();
}
inline void Registration::add_ipaddress(const ::std::string& value) {
  ipaddress_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ddc.distributor.Registration.ipAddress)
}
inline void Registration::add_ipaddress(const char* value) {
  ipaddress_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ddc.distributor.Registration.ipAddress)
}
inline void Registration::add_ipaddress(const char* value, size_t size) {
  ipaddress_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ddc.distributor.Registration.ipAddress)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Registration::ipaddress() const {
  // @@protoc_insertion_point(field_list:ddc.distributor.Registration.ipAddress)
  return ipaddress_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Registration::mutable_ipaddress() {
  // @@protoc_insertion_point(field_mutable_list:ddc.distributor.Registration.ipAddress)
  return &ipaddress_;
}

// -------------------------------------------------------------------

// FetchSplitRequest

// required string tag = 1;
inline bool FetchSplitRequest::has_tag() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FetchSplitRequest::set_has_tag() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FetchSplitRequest::clear_has_tag() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FetchSplitRequest::clear_tag() {
  if (tag_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tag_->clear();
  }
  clear_has_tag();
}
inline const ::std::string& FetchSplitRequest::tag() const {
  // @@protoc_insertion_point(field_get:ddc.distributor.FetchSplitRequest.tag)
  return *tag_;
}
inline void FetchSplitRequest::set_tag(const ::std::string& value) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tag_ = new ::std::string;
  }
  tag_->assign(value);
  // @@protoc_insertion_point(field_set:ddc.distributor.FetchSplitRequest.tag)
}
inline void FetchSplitRequest::set_tag(const char* value) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tag_ = new ::std::string;
  }
  tag_->assign(value);
  // @@protoc_insertion_point(field_set_char:ddc.distributor.FetchSplitRequest.tag)
}
inline void FetchSplitRequest::set_tag(const char* value, size_t size) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tag_ = new ::std::string;
  }
  tag_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ddc.distributor.FetchSplitRequest.tag)
}
inline ::std::string* FetchSplitRequest::mutable_tag() {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tag_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ddc.distributor.FetchSplitRequest.tag)
  return tag_;
}
inline ::std::string* FetchSplitRequest::release_tag() {
  clear_has_tag();
  if (tag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = tag_;
    tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void FetchSplitRequest::set_allocated_tag(::std::string* tag) {
  if (tag_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete tag_;
  }
  if (tag) {
    set_has_tag();
    tag_ = tag;
  } else {
    clear_has_tag();
    tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ddc.distributor.FetchSplitRequest.tag)
}

// required string filename = 2;
inline bool FetchSplitRequest::has_filename() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FetchSplitRequest::set_has_filename() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FetchSplitRequest::clear_has_filename() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FetchSplitRequest::clear_filename() {
  if (filename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& FetchSplitRequest::filename() const {
  // @@protoc_insertion_point(field_get:ddc.distributor.FetchSplitRequest.filename)
  return *filename_;
}
inline void FetchSplitRequest::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
  // @@protoc_insertion_point(field_set:ddc.distributor.FetchSplitRequest.filename)
}
inline void FetchSplitRequest::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
  // @@protoc_insertion_point(field_set_char:ddc.distributor.FetchSplitRequest.filename)
}
inline void FetchSplitRequest::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ddc.distributor.FetchSplitRequest.filename)
}
inline ::std::string* FetchSplitRequest::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filename_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ddc.distributor.FetchSplitRequest.filename)
  return filename_;
}
inline ::std::string* FetchSplitRequest::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void FetchSplitRequest::set_allocated_filename(::std::string* filename) {
  if (filename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete filename_;
  }
  if (filename) {
    set_has_filename();
    filename_ = filename;
  } else {
    clear_has_filename();
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ddc.distributor.FetchSplitRequest.filename)
}

// required uint64 start = 3;
inline bool FetchSplitRequest::has_start() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FetchSplitRequest::set_has_start() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FetchSplitRequest::clear_has_start() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FetchSplitRequest::clear_start() {
  start_ = GOOGLE_ULONGLONG(0);
  clear_has_start();
}
inline ::google::protobuf::uint64 FetchSplitRequest::start() const {
  // @@protoc_insertion_point(field_get:ddc.distributor.FetchSplitRequest.start)
  return start_;
}
inline void FetchSplitRequest::set_start(::google::protobuf::uint64 value) {
  set_has_start();
  start_ = value;
  // @@protoc_insertion_point(field_set:ddc.distributor.FetchSplitRequest.start)
}

// required uint64 end = 4;
inline bool FetchSplitRequest::has_end() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FetchSplitRequest::set_has_end() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FetchSplitRequest::clear_has_end() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FetchSplitRequest::clear_end() {
  end_ = GOOGLE_ULONGLONG(0);
  clear_has_end();
}
inline ::google::protobuf::uint64 FetchSplitRequest::end() const {
  // @@protoc_insertion_point(field_get:ddc.distributor.FetchSplitRequest.end)
  return end_;
}
inline void FetchSplitRequest::set_end(::google::protobuf::uint64 value) {
  set_has_end();
  end_ = value;
  // @@protoc_insertion_point(field_set:ddc.distributor.FetchSplitRequest.end)
}

// required string schema = 5;
inline bool FetchSplitRequest::has_schema() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FetchSplitRequest::set_has_schema() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FetchSplitRequest::clear_has_schema() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FetchSplitRequest::clear_schema() {
  if (schema_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    schema_->clear();
  }
  clear_has_schema();
}
inline const ::std::string& FetchSplitRequest::schema() const {
  // @@protoc_insertion_point(field_get:ddc.distributor.FetchSplitRequest.schema)
  return *schema_;
}
inline void FetchSplitRequest::set_schema(const ::std::string& value) {
  set_has_schema();
  if (schema_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    schema_ = new ::std::string;
  }
  schema_->assign(value);
  // @@protoc_insertion_point(field_set:ddc.distributor.FetchSplitRequest.schema)
}
inline void FetchSplitRequest::set_schema(const char* value) {
  set_has_schema();
  if (schema_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    schema_ = new ::std::string;
  }
  schema_->assign(value);
  // @@protoc_insertion_point(field_set_char:ddc.distributor.FetchSplitRequest.schema)
}
inline void FetchSplitRequest::set_schema(const char* value, size_t size) {
  set_has_schema();
  if (schema_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    schema_ = new ::std::string;
  }
  schema_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ddc.distributor.FetchSplitRequest.schema)
}
inline ::std::string* FetchSplitRequest::mutable_schema() {
  set_has_schema();
  if (schema_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    schema_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ddc.distributor.FetchSplitRequest.schema)
  return schema_;
}
inline ::std::string* FetchSplitRequest::release_schema() {
  clear_has_schema();
  if (schema_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = schema_;
    schema_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void FetchSplitRequest::set_allocated_schema(::std::string* schema) {
  if (schema_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete schema_;
  }
  if (schema) {
    set_has_schema();
    schema_ = schema;
  } else {
    clear_has_schema();
    schema_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ddc.distributor.FetchSplitRequest.schema)
}

// required string objectType = 6;
inline bool FetchSplitRequest::has_objecttype() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FetchSplitRequest::set_has_objecttype() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FetchSplitRequest::clear_has_objecttype() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FetchSplitRequest::clear_objecttype() {
  if (objecttype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    objecttype_->clear();
  }
  clear_has_objecttype();
}
inline const ::std::string& FetchSplitRequest::objecttype() const {
  // @@protoc_insertion_point(field_get:ddc.distributor.FetchSplitRequest.objectType)
  return *objecttype_;
}
inline void FetchSplitRequest::set_objecttype(const ::std::string& value) {
  set_has_objecttype();
  if (objecttype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    objecttype_ = new ::std::string;
  }
  objecttype_->assign(value);
  // @@protoc_insertion_point(field_set:ddc.distributor.FetchSplitRequest.objectType)
}
inline void FetchSplitRequest::set_objecttype(const char* value) {
  set_has_objecttype();
  if (objecttype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    objecttype_ = new ::std::string;
  }
  objecttype_->assign(value);
  // @@protoc_insertion_point(field_set_char:ddc.distributor.FetchSplitRequest.objectType)
}
inline void FetchSplitRequest::set_objecttype(const char* value, size_t size) {
  set_has_objecttype();
  if (objecttype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    objecttype_ = new ::std::string;
  }
  objecttype_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ddc.distributor.FetchSplitRequest.objectType)
}
inline ::std::string* FetchSplitRequest::mutable_objecttype() {
  set_has_objecttype();
  if (objecttype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    objecttype_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ddc.distributor.FetchSplitRequest.objectType)
  return objecttype_;
}
inline ::std::string* FetchSplitRequest::release_objecttype() {
  clear_has_objecttype();
  if (objecttype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = objecttype_;
    objecttype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void FetchSplitRequest::set_allocated_objecttype(::std::string* objecttype) {
  if (objecttype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete objecttype_;
  }
  if (objecttype) {
    set_has_objecttype();
    objecttype_ = objecttype;
  } else {
    clear_has_objecttype();
    objecttype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ddc.distributor.FetchSplitRequest.objectType)
}

// -------------------------------------------------------------------

// FetchSplitResponse

// required string tag = 1;
inline bool FetchSplitResponse::has_tag() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FetchSplitResponse::set_has_tag() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FetchSplitResponse::clear_has_tag() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FetchSplitResponse::clear_tag() {
  if (tag_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tag_->clear();
  }
  clear_has_tag();
}
inline const ::std::string& FetchSplitResponse::tag() const {
  // @@protoc_insertion_point(field_get:ddc.distributor.FetchSplitResponse.tag)
  return *tag_;
}
inline void FetchSplitResponse::set_tag(const ::std::string& value) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tag_ = new ::std::string;
  }
  tag_->assign(value);
  // @@protoc_insertion_point(field_set:ddc.distributor.FetchSplitResponse.tag)
}
inline void FetchSplitResponse::set_tag(const char* value) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tag_ = new ::std::string;
  }
  tag_->assign(value);
  // @@protoc_insertion_point(field_set_char:ddc.distributor.FetchSplitResponse.tag)
}
inline void FetchSplitResponse::set_tag(const char* value, size_t size) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tag_ = new ::std::string;
  }
  tag_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ddc.distributor.FetchSplitResponse.tag)
}
inline ::std::string* FetchSplitResponse::mutable_tag() {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tag_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ddc.distributor.FetchSplitResponse.tag)
  return tag_;
}
inline ::std::string* FetchSplitResponse::release_tag() {
  clear_has_tag();
  if (tag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = tag_;
    tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void FetchSplitResponse::set_allocated_tag(::std::string* tag) {
  if (tag_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete tag_;
  }
  if (tag) {
    set_has_tag();
    tag_ = tag;
  } else {
    clear_has_tag();
    tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ddc.distributor.FetchSplitResponse.tag)
}

// required int32 status = 2;
inline bool FetchSplitResponse::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FetchSplitResponse::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FetchSplitResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FetchSplitResponse::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 FetchSplitResponse::status() const {
  // @@protoc_insertion_point(field_get:ddc.distributor.FetchSplitResponse.status)
  return status_;
}
inline void FetchSplitResponse::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:ddc.distributor.FetchSplitResponse.status)
}

// -------------------------------------------------------------------

// HeartBeatRequest

// -------------------------------------------------------------------

// HeartBeatResponse

// -------------------------------------------------------------------

// ShutdownRequest

// -------------------------------------------------------------------

// ProgressUpdate

// required string tag = 1;
inline bool ProgressUpdate::has_tag() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProgressUpdate::set_has_tag() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProgressUpdate::clear_has_tag() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProgressUpdate::clear_tag() {
  if (tag_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tag_->clear();
  }
  clear_has_tag();
}
inline const ::std::string& ProgressUpdate::tag() const {
  // @@protoc_insertion_point(field_get:ddc.distributor.ProgressUpdate.tag)
  return *tag_;
}
inline void ProgressUpdate::set_tag(const ::std::string& value) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tag_ = new ::std::string;
  }
  tag_->assign(value);
  // @@protoc_insertion_point(field_set:ddc.distributor.ProgressUpdate.tag)
}
inline void ProgressUpdate::set_tag(const char* value) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tag_ = new ::std::string;
  }
  tag_->assign(value);
  // @@protoc_insertion_point(field_set_char:ddc.distributor.ProgressUpdate.tag)
}
inline void ProgressUpdate::set_tag(const char* value, size_t size) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tag_ = new ::std::string;
  }
  tag_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ddc.distributor.ProgressUpdate.tag)
}
inline ::std::string* ProgressUpdate::mutable_tag() {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tag_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ddc.distributor.ProgressUpdate.tag)
  return tag_;
}
inline ::std::string* ProgressUpdate::release_tag() {
  clear_has_tag();
  if (tag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = tag_;
    tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ProgressUpdate::set_allocated_tag(::std::string* tag) {
  if (tag_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete tag_;
  }
  if (tag) {
    set_has_tag();
    tag_ = tag;
  } else {
    clear_has_tag();
    tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ddc.distributor.ProgressUpdate.tag)
}

// required uint64 bytesCompleted = 2;
inline bool ProgressUpdate::has_bytescompleted() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProgressUpdate::set_has_bytescompleted() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProgressUpdate::clear_has_bytescompleted() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProgressUpdate::clear_bytescompleted() {
  bytescompleted_ = GOOGLE_ULONGLONG(0);
  clear_has_bytescompleted();
}
inline ::google::protobuf::uint64 ProgressUpdate::bytescompleted() const {
  // @@protoc_insertion_point(field_get:ddc.distributor.ProgressUpdate.bytesCompleted)
  return bytescompleted_;
}
inline void ProgressUpdate::set_bytescompleted(::google::protobuf::uint64 value) {
  set_has_bytescompleted();
  bytescompleted_ = value;
  // @@protoc_insertion_point(field_set:ddc.distributor.ProgressUpdate.bytesCompleted)
}

// required uint64 bytesTotal = 3;
inline bool ProgressUpdate::has_bytestotal() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProgressUpdate::set_has_bytestotal() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProgressUpdate::clear_has_bytestotal() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProgressUpdate::clear_bytestotal() {
  bytestotal_ = GOOGLE_ULONGLONG(0);
  clear_has_bytestotal();
}
inline ::google::protobuf::uint64 ProgressUpdate::bytestotal() const {
  // @@protoc_insertion_point(field_get:ddc.distributor.ProgressUpdate.bytesTotal)
  return bytestotal_;
}
inline void ProgressUpdate::set_bytestotal(::google::protobuf::uint64 value) {
  set_has_bytestotal();
  bytestotal_ = value;
  // @@protoc_insertion_point(field_set:ddc.distributor.ProgressUpdate.bytesTotal)
}

// -------------------------------------------------------------------

// AnyRequest

// required .ddc.distributor.AnyRequest.Type type = 1;
inline bool AnyRequest::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AnyRequest::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AnyRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AnyRequest::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::ddc::distributor::AnyRequest_Type AnyRequest::type() const {
  // @@protoc_insertion_point(field_get:ddc.distributor.AnyRequest.type)
  return static_cast< ::ddc::distributor::AnyRequest_Type >(type_);
}
inline void AnyRequest::set_type(::ddc::distributor::AnyRequest_Type value) {
  assert(::ddc::distributor::AnyRequest_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:ddc.distributor.AnyRequest.type)
}

// optional .ddc.distributor.Registration registration = 2;
inline bool AnyRequest::has_registration() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AnyRequest::set_has_registration() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AnyRequest::clear_has_registration() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AnyRequest::clear_registration() {
  if (registration_ != NULL) registration_->::ddc::distributor::Registration::Clear();
  clear_has_registration();
}
inline const ::ddc::distributor::Registration& AnyRequest::registration() const {
  // @@protoc_insertion_point(field_get:ddc.distributor.AnyRequest.registration)
  return registration_ != NULL ? *registration_ : *default_instance_->registration_;
}
inline ::ddc::distributor::Registration* AnyRequest::mutable_registration() {
  set_has_registration();
  if (registration_ == NULL) registration_ = new ::ddc::distributor::Registration;
  // @@protoc_insertion_point(field_mutable:ddc.distributor.AnyRequest.registration)
  return registration_;
}
inline ::ddc::distributor::Registration* AnyRequest::release_registration() {
  clear_has_registration();
  ::ddc::distributor::Registration* temp = registration_;
  registration_ = NULL;
  return temp;
}
inline void AnyRequest::set_allocated_registration(::ddc::distributor::Registration* registration) {
  delete registration_;
  registration_ = registration;
  if (registration) {
    set_has_registration();
  } else {
    clear_has_registration();
  }
  // @@protoc_insertion_point(field_set_allocated:ddc.distributor.AnyRequest.registration)
}

// optional .ddc.distributor.FetchSplitRequest fetchSplitRequest = 3;
inline bool AnyRequest::has_fetchsplitrequest() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AnyRequest::set_has_fetchsplitrequest() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AnyRequest::clear_has_fetchsplitrequest() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AnyRequest::clear_fetchsplitrequest() {
  if (fetchsplitrequest_ != NULL) fetchsplitrequest_->::ddc::distributor::FetchSplitRequest::Clear();
  clear_has_fetchsplitrequest();
}
inline const ::ddc::distributor::FetchSplitRequest& AnyRequest::fetchsplitrequest() const {
  // @@protoc_insertion_point(field_get:ddc.distributor.AnyRequest.fetchSplitRequest)
  return fetchsplitrequest_ != NULL ? *fetchsplitrequest_ : *default_instance_->fetchsplitrequest_;
}
inline ::ddc::distributor::FetchSplitRequest* AnyRequest::mutable_fetchsplitrequest() {
  set_has_fetchsplitrequest();
  if (fetchsplitrequest_ == NULL) fetchsplitrequest_ = new ::ddc::distributor::FetchSplitRequest;
  // @@protoc_insertion_point(field_mutable:ddc.distributor.AnyRequest.fetchSplitRequest)
  return fetchsplitrequest_;
}
inline ::ddc::distributor::FetchSplitRequest* AnyRequest::release_fetchsplitrequest() {
  clear_has_fetchsplitrequest();
  ::ddc::distributor::FetchSplitRequest* temp = fetchsplitrequest_;
  fetchsplitrequest_ = NULL;
  return temp;
}
inline void AnyRequest::set_allocated_fetchsplitrequest(::ddc::distributor::FetchSplitRequest* fetchsplitrequest) {
  delete fetchsplitrequest_;
  fetchsplitrequest_ = fetchsplitrequest;
  if (fetchsplitrequest) {
    set_has_fetchsplitrequest();
  } else {
    clear_has_fetchsplitrequest();
  }
  // @@protoc_insertion_point(field_set_allocated:ddc.distributor.AnyRequest.fetchSplitRequest)
}

// optional .ddc.distributor.FetchSplitResponse fetchSplitResponse = 4;
inline bool AnyRequest::has_fetchsplitresponse() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AnyRequest::set_has_fetchsplitresponse() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AnyRequest::clear_has_fetchsplitresponse() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AnyRequest::clear_fetchsplitresponse() {
  if (fetchsplitresponse_ != NULL) fetchsplitresponse_->::ddc::distributor::FetchSplitResponse::Clear();
  clear_has_fetchsplitresponse();
}
inline const ::ddc::distributor::FetchSplitResponse& AnyRequest::fetchsplitresponse() const {
  // @@protoc_insertion_point(field_get:ddc.distributor.AnyRequest.fetchSplitResponse)
  return fetchsplitresponse_ != NULL ? *fetchsplitresponse_ : *default_instance_->fetchsplitresponse_;
}
inline ::ddc::distributor::FetchSplitResponse* AnyRequest::mutable_fetchsplitresponse() {
  set_has_fetchsplitresponse();
  if (fetchsplitresponse_ == NULL) fetchsplitresponse_ = new ::ddc::distributor::FetchSplitResponse;
  // @@protoc_insertion_point(field_mutable:ddc.distributor.AnyRequest.fetchSplitResponse)
  return fetchsplitresponse_;
}
inline ::ddc::distributor::FetchSplitResponse* AnyRequest::release_fetchsplitresponse() {
  clear_has_fetchsplitresponse();
  ::ddc::distributor::FetchSplitResponse* temp = fetchsplitresponse_;
  fetchsplitresponse_ = NULL;
  return temp;
}
inline void AnyRequest::set_allocated_fetchsplitresponse(::ddc::distributor::FetchSplitResponse* fetchsplitresponse) {
  delete fetchsplitresponse_;
  fetchsplitresponse_ = fetchsplitresponse;
  if (fetchsplitresponse) {
    set_has_fetchsplitresponse();
  } else {
    clear_has_fetchsplitresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:ddc.distributor.AnyRequest.fetchSplitResponse)
}

// optional .ddc.distributor.HeartBeatRequest heartBeatRequest = 5;
inline bool AnyRequest::has_heartbeatrequest() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AnyRequest::set_has_heartbeatrequest() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AnyRequest::clear_has_heartbeatrequest() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AnyRequest::clear_heartbeatrequest() {
  if (heartbeatrequest_ != NULL) heartbeatrequest_->::ddc::distributor::HeartBeatRequest::Clear();
  clear_has_heartbeatrequest();
}
inline const ::ddc::distributor::HeartBeatRequest& AnyRequest::heartbeatrequest() const {
  // @@protoc_insertion_point(field_get:ddc.distributor.AnyRequest.heartBeatRequest)
  return heartbeatrequest_ != NULL ? *heartbeatrequest_ : *default_instance_->heartbeatrequest_;
}
inline ::ddc::distributor::HeartBeatRequest* AnyRequest::mutable_heartbeatrequest() {
  set_has_heartbeatrequest();
  if (heartbeatrequest_ == NULL) heartbeatrequest_ = new ::ddc::distributor::HeartBeatRequest;
  // @@protoc_insertion_point(field_mutable:ddc.distributor.AnyRequest.heartBeatRequest)
  return heartbeatrequest_;
}
inline ::ddc::distributor::HeartBeatRequest* AnyRequest::release_heartbeatrequest() {
  clear_has_heartbeatrequest();
  ::ddc::distributor::HeartBeatRequest* temp = heartbeatrequest_;
  heartbeatrequest_ = NULL;
  return temp;
}
inline void AnyRequest::set_allocated_heartbeatrequest(::ddc::distributor::HeartBeatRequest* heartbeatrequest) {
  delete heartbeatrequest_;
  heartbeatrequest_ = heartbeatrequest;
  if (heartbeatrequest) {
    set_has_heartbeatrequest();
  } else {
    clear_has_heartbeatrequest();
  }
  // @@protoc_insertion_point(field_set_allocated:ddc.distributor.AnyRequest.heartBeatRequest)
}

// optional .ddc.distributor.HeartBeatResponse heartBeatResponse = 6;
inline bool AnyRequest::has_heartbeatresponse() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AnyRequest::set_has_heartbeatresponse() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AnyRequest::clear_has_heartbeatresponse() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AnyRequest::clear_heartbeatresponse() {
  if (heartbeatresponse_ != NULL) heartbeatresponse_->::ddc::distributor::HeartBeatResponse::Clear();
  clear_has_heartbeatresponse();
}
inline const ::ddc::distributor::HeartBeatResponse& AnyRequest::heartbeatresponse() const {
  // @@protoc_insertion_point(field_get:ddc.distributor.AnyRequest.heartBeatResponse)
  return heartbeatresponse_ != NULL ? *heartbeatresponse_ : *default_instance_->heartbeatresponse_;
}
inline ::ddc::distributor::HeartBeatResponse* AnyRequest::mutable_heartbeatresponse() {
  set_has_heartbeatresponse();
  if (heartbeatresponse_ == NULL) heartbeatresponse_ = new ::ddc::distributor::HeartBeatResponse;
  // @@protoc_insertion_point(field_mutable:ddc.distributor.AnyRequest.heartBeatResponse)
  return heartbeatresponse_;
}
inline ::ddc::distributor::HeartBeatResponse* AnyRequest::release_heartbeatresponse() {
  clear_has_heartbeatresponse();
  ::ddc::distributor::HeartBeatResponse* temp = heartbeatresponse_;
  heartbeatresponse_ = NULL;
  return temp;
}
inline void AnyRequest::set_allocated_heartbeatresponse(::ddc::distributor::HeartBeatResponse* heartbeatresponse) {
  delete heartbeatresponse_;
  heartbeatresponse_ = heartbeatresponse;
  if (heartbeatresponse) {
    set_has_heartbeatresponse();
  } else {
    clear_has_heartbeatresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:ddc.distributor.AnyRequest.heartBeatResponse)
}

// optional .ddc.distributor.ShutdownRequest shutdownRequest = 7;
inline bool AnyRequest::has_shutdownrequest() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AnyRequest::set_has_shutdownrequest() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AnyRequest::clear_has_shutdownrequest() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AnyRequest::clear_shutdownrequest() {
  if (shutdownrequest_ != NULL) shutdownrequest_->::ddc::distributor::ShutdownRequest::Clear();
  clear_has_shutdownrequest();
}
inline const ::ddc::distributor::ShutdownRequest& AnyRequest::shutdownrequest() const {
  // @@protoc_insertion_point(field_get:ddc.distributor.AnyRequest.shutdownRequest)
  return shutdownrequest_ != NULL ? *shutdownrequest_ : *default_instance_->shutdownrequest_;
}
inline ::ddc::distributor::ShutdownRequest* AnyRequest::mutable_shutdownrequest() {
  set_has_shutdownrequest();
  if (shutdownrequest_ == NULL) shutdownrequest_ = new ::ddc::distributor::ShutdownRequest;
  // @@protoc_insertion_point(field_mutable:ddc.distributor.AnyRequest.shutdownRequest)
  return shutdownrequest_;
}
inline ::ddc::distributor::ShutdownRequest* AnyRequest::release_shutdownrequest() {
  clear_has_shutdownrequest();
  ::ddc::distributor::ShutdownRequest* temp = shutdownrequest_;
  shutdownrequest_ = NULL;
  return temp;
}
inline void AnyRequest::set_allocated_shutdownrequest(::ddc::distributor::ShutdownRequest* shutdownrequest) {
  delete shutdownrequest_;
  shutdownrequest_ = shutdownrequest;
  if (shutdownrequest) {
    set_has_shutdownrequest();
  } else {
    clear_has_shutdownrequest();
  }
  // @@protoc_insertion_point(field_set_allocated:ddc.distributor.AnyRequest.shutdownRequest)
}

// optional .ddc.distributor.ProgressUpdate progressUpdate = 8;
inline bool AnyRequest::has_progressupdate() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AnyRequest::set_has_progressupdate() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AnyRequest::clear_has_progressupdate() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AnyRequest::clear_progressupdate() {
  if (progressupdate_ != NULL) progressupdate_->::ddc::distributor::ProgressUpdate::Clear();
  clear_has_progressupdate();
}
inline const ::ddc::distributor::ProgressUpdate& AnyRequest::progressupdate() const {
  // @@protoc_insertion_point(field_get:ddc.distributor.AnyRequest.progressUpdate)
  return progressupdate_ != NULL ? *progressupdate_ : *default_instance_->progressupdate_;
}
inline ::ddc::distributor::ProgressUpdate* AnyRequest::mutable_progressupdate() {
  set_has_progressupdate();
  if (progressupdate_ == NULL) progressupdate_ = new ::ddc::distributor::ProgressUpdate;
  // @@protoc_insertion_point(field_mutable:ddc.distributor.AnyRequest.progressUpdate)
  return progressupdate_;
}
inline ::ddc::distributor::ProgressUpdate* AnyRequest::release_progressupdate() {
  clear_has_progressupdate();
  ::ddc::distributor::ProgressUpdate* temp = progressupdate_;
  progressupdate_ = NULL;
  return temp;
}
inline void AnyRequest::set_allocated_progressupdate(::ddc::distributor::ProgressUpdate* progressupdate) {
  delete progressupdate_;
  progressupdate_ = progressupdate;
  if (progressupdate) {
    set_has_progressupdate();
  } else {
    clear_has_progressupdate();
  }
  // @@protoc_insertion_point(field_set_allocated:ddc.distributor.AnyRequest.progressUpdate)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace distributor
}  // namespace ddc

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::ddc::distributor::AnyRequest_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ddc::distributor::AnyRequest_Type>() {
  return ::ddc::distributor::AnyRequest_Type_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_distributor_2eproto__INCLUDED
